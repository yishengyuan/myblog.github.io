
## **1️⃣ 引用计数算法（Reference Counting）**

- **原理**：每个对象维护一个引用计数器，引用 +1，引用消失 -1。
    
- **优点**：实现简单，能及时回收没有被引用的对象。
    
- **缺点**：
    
    - **无法处理循环引用**（A→B→A，即使没人引用，也无法回收）
        
- **使用情况**：JVM 不使用它作为主流GC算法，但某些语言（如早期Python）会用作辅助手段。

## **2️⃣ 可达性分析算法（Reachability Analysis）**

- **原理**：从 **GC Roots** 出发，能到达的对象为存活，不可达对象为垃圾。
    
- **优点**：能解决循环引用问题
    
- **缺点**：需要遍历引用图，性能消耗较大
    
- **使用情况**：现代 JVM 的主要算法

## **3️⃣ 分代收集算法（Generational Collection）**

- **原理**：将堆分为 **Young区**、**Old区**（元空间在JDK8后独立），分别采用不同的策略：
    
    - **新生代（Young）**：
        
        - 对象存活时间短 → 使用 **复制算法（Copying）**
            
    - **老年代（Old）**：
        
        - 对象存活时间长 → 使用 **标记-清除（Mark-Sweep）** 或 **标记-整理（Mark-Compact）**
            
- **优点**：提高GC效率，减少停顿
    
- **JVM典型实现**：
    
    - 新生代 Minor GC → **复制算法**
        
    - 老年代 Full GC → **标记-整理/标记-清除**
## **4️⃣ 标记-清除算法（Mark-Sweep）**

- **步骤**：
    
    1. **标记**：标记所有可达对象
        
    2. **清除**：未标记对象回收
        
- **缺点**：
    
    - 会产生内存碎片
        
- **使用场景**：Old GC / Full GC

## **5️⃣ 标记-整理算法（Mark-Compact）**

- **步骤**：
    
    1. **标记**可达对象
        
    2. **整理**存活对象 → 移动到连续空间
        
- **优点**：
    
    - 避免内存碎片
        
- **缺点**：
    
    - 移动对象需要更新引用，开销较大
        

---

## **6️⃣ 复制算法（Copying）**

- **步骤**：
    
    1. 将内存分为两块，A区和B区
        
    2. GC 时，把存活对象从A区复制到B区
        
    3. 清空A区
        
- **优点**：
    
    - 无碎片，GC速度快
        
- **缺点**：
    
    - 内存利用率低（需要两块相等空间）
        
- **使用场景**：Young GC

## **7️⃣ 分代 + 不同策略结合**

JVM 常用策略：

| 内存区       | GC算法          | 特点              |
| --------- | ------------- | --------------- |
| Young     | 复制算法（Copying） | 快速回收，频繁Minor GC |
| Old       | 标记-清除/标记-整理   | 停顿时间长，回收大对象     |
| Metaspace | 标记-清除         | 类卸载             |
|           |               |                 |

---

✅ **总结思路**：

1. **引用计数** → 简单但有循环引用问题
    
2. **可达性分析** → GC主流算法
    
3. **标记-清除** → 回收老年代，易碎片
    
4. **标记-整理** → 避免碎片，开销大
    
5. **复制算法** → 新生代，快速
    
6. **分代收集** → 综合使用，提高效率
![[Pasted image 20251129195437.png]]