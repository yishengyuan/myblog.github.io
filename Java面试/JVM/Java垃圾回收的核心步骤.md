# ✅ **Java 垃圾回收（GC）的核心步骤**

Java 的 GC 本质上就是一句话：  
**标记存活对象 → 清理无用对象 → 整理内存（可选）**

通常包含以下大步骤（按 HotSpot 常见实现）：

---

## **1. Root Scanning（从 GC Roots 开始扫描）**

GC 从一组叫 **GC Roots** 的根节点开始，包括：

- 栈中的引用（局部变量）
    
- 方法区中的静态变量
    
- 常量引用
    
- JNI 本地方法引用
    

目的：找到所有可达对象。

---

## **2. 可达性分析（Reachability Analysis）**

从 Roots 往下递归遍历，标记 **所有仍然能被访问的对象**。

结果分两类：

- **存活对象：可达**
    
- **垃圾对象：不可达**
    

---

## **3. 标记阶段（Mark）**

把所有 **可达对象** 打上标记（大多采用 Bitmap 位图结构）。

此阶段可能导致 STW（Stop-the-world）。

---

## **4. 清除阶段（Sweep）**

把没有标记的对象全部释放掉，回收空间。

不同 GC 的处理方式不一样：

### **Serial / Parallel：标记-清除**

- 清除未标记对象
    
- 可能产生碎片
    

### **CMS：并发标记-清除**

- 更少 STW，但依然会产生碎片
    

---

## **5. 整理/压缩阶段（Compact） —— 部分 GC 会做**

垃圾清除后，有些 GC 会进行内存整理，把存活对象移动到一起，消除碎片。

比如：

### **G1、Serial、Parallel：标记-压缩（Mark-Compact）**

- 存活对象移动
    
- 得到连续内存，提高分配效率
    

CMS 不做压缩，ZGC/ Shenandoah 采用并发移动对象。

---

## **6. 更新引用（Relocate Pointer）**

当对象移动后，需要更新：

- 其他对象内部的引用
    
- 栈帧中的引用
    
- JIT Cache
    
- Remembered Set（如 G1 使用）
    

ZGC/Shenandoah 使用“读屏障”+“着色指针”来避免 STW 大停顿。

---

# 🔍 **总结成一句非常适合面试背诵的话**

> Java 垃圾回收主要分为三大步骤：  
> **先从 GC Roots 开始做可达性分析，对存活对象进行标记；  
> 然后清除未被标记的对象；  
> 部分 GC 会进一步对存活对象进行压缩整理并更新引用，减少内存碎片。**

---

# 🔥 Bonus：提到不同 GC 的差异可以加分

|GC 类型|工作方式|
|---|---|
|**Serial/Parallel**|标记-复制（新生代），标记-压缩（老年代）|
|**CMS**|并发标记-清除，不压缩|
|**G1**|分区回收，标记-复制（区域级），有压缩|
|**ZGC / Shenandoah**|并发标记 + 并发复制，不 STW|
