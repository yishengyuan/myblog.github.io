选择 GC 的核心原则只有 **一句话**：

> **根据你的项目是“延迟优先”还是“吞吐量优先”来选 GC。  
> 然后根据内存规模和停顿指标做微调。**

# 🎯 **第一步：明确你的业务类型**

| 业务类型                                             | 需求                    | 适合的回收器                        |
| ------------------------------------------------ | --------------------- | ----------------------------- |
| **高延迟敏感（低延迟）**  <br>支付、撮合、交易系统、IM、风控、广告、Web3 RPC | 关键在“停顿最短”，不允许卡顿       | **ZGC（首选）** / Shenandoah / G1 |
| **吞吐量优先（不敏感延迟）**  <br>日志处理、大批量任务、离线计算（Spark）、批处理 | 要求“单位时间处理最多”，偶尔卡顿可接受  | **ParallelGC**                |
| **普通互联网（平衡型）**  <br>大部分 Web 服务、微服务               | 既要延迟，也要吞吐             | **G1（默认选）**                   |
| **内存小于 4GB 的小服务**                                | 频繁 Young GC 即可解决，简单可靠 | **ParallelGC / G1 都可**        |
# 🎯 **第二步：根据内存规模决定**

| 堆大小                | 推荐 GC             | 理由                  |
| ------------------ | ----------------- | ------------------- |
| **<4GB**           | Parallel / G1     | 小堆暂停短，Parallel 反而更快 |
| **4GB ~ 32GB**     | G1                | 分区化 + 并发标记，延迟可控     |
| **32GB ~ 512GB**   | **G1 → ZGC**（看延迟） | G1 会开始偏慢，ZGC 优势明显   |
| **>512GB~1TB~多TB** | **ZGC（唯一合理选择）**   | G1/CMS 无法承受，全堆标记太慢  |
|                    |                   |                     |
# 🎯 **第三步：看延迟指标（非常关键）**

## ❗如果要求 P99 < 10ms

选：

- **ZGC（最优）**
    
- Shenandoah（次选）
    

## ❗如果能接受 P99 = 50~200ms

选：

- **G1（绝大多数互联网服务的选择）**
    

## ❗如果不在乎停顿，反而想吞吐量最大化

选：

- **ParallelGC（吞吐量最高）**
    

---

# 🎯 **第四步：按 GC 的优缺点做最终决策**

### **1. ParallelGC（吞吐量最高）**

适用场景：

- 批处理
    
- 大任务
    
- 离线计算
    
- 游戏服务器（非关键线程）
    
- 消息堆积处理
    

优点：最快  
缺点：STW 最长

---

### **2. G1（最常用“通用 GC”）**

几乎可以适应所有互联网场景：

- 微服务
    
- Web 应用
    
- RPC
    
- 中等延迟要求
    

优点：

- 延迟低（十毫秒级）
    
- 吞吐量也不错
    
- 分区清理减少碎片
    

缺点：

- 大堆性能逐渐下降
    

---

### **3. ZGC（现代GC之王，真正全并发移动）**

适用于：

- 高频请求
    
- 金融交易
    
- 支付
    
- 撮合系统
    
- 高负载互联网核心 API
    
- 低延迟 RPC
    
- 大堆（>100GB）
    

优点：

- 延迟** ≤1ms**
    
- 大堆仍然快速
    
- 并发移动对象
    

缺点：

- CPU 占用略高（屏障开销）
    
- 旧版本 JDK 支持不完善（JDK 17 之后已非常成熟）
    

---

### **4. Shenandoah（OpenJDK 红帽系）**

适用于：

- OpenJDK 发行版
    
- 低延迟场景
    

但生态上不如 ZGC，Java 官方推 ZGC。

---

# 📌 **最终给你一句面试“完美回答”**

> 实际项目中，GC 选择的优先级是：  
> **业务延迟要求 > 堆大小 > 吞吐量需求**。  
> 如果对停顿敏感或堆很大，选 **ZGC**；  
> 如果是普通线上服务，选 **G1**；  
> 如果是批处理吞吐量优先，选 **ParallelGC**。  
> 这三个基本覆盖所有生产场景。