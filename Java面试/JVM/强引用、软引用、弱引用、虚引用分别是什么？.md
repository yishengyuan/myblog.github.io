## **1️⃣ 强引用（Strong Reference）**

- **定义**：普通的引用，就是我们平时用的。
    
    `Object obj = new Object(); // 强引用`
- **特点**：
    
    - 只要强引用还在，垃圾回收器**不会回收对象**。
        
    - 可能导致内存泄漏，如果对象长时间不释放。
        
- **应用场景**：绝大多数对象都是强引用。
## **2️⃣ 软引用（Soft Reference）**

- **定义**：使用 `SoftReference` 包装的引用。
    
    `SoftReference<Object> softRef = new SoftReference<>(obj);`
    
- **特点**：
    
    - **内存充足时**：对象不会被回收。
        
    - **内存不足时**：垃圾回收器会回收软引用指向的对象。
        
    - **可以用作缓存**。
        
- **应用场景**：实现内存敏感缓存，比如图片缓存。

## **3️⃣ 弱引用（Weak Reference）**

- **定义**：使用 `WeakReference` 包装的引用。
    
    `WeakReference<Object> weakRef = new WeakReference<>(obj);`
    
- **特点**：
    
    - **只要 GC 一发生**，对象就会被回收。
        
    - 弱引用通常用来做**规范映射**（WeakHashMap）等。
        
- **应用场景**：需要随时回收的对象引用，比如线程局部缓存、映射表中引用对象。
## **4️⃣ 虚引用（Phantom Reference）**

- **定义**：使用 `PhantomReference` 包装的引用，需要配合 `ReferenceQueue`。
    
    `ReferenceQueue<Object> queue = new ReferenceQueue<>(); PhantomReference<Object> phantomRef = new PhantomReference<>(obj, queue);`
    
- **特点**：
    
    - **虚引用不会影响对象生命周期**，对象**随时可以被 GC 回收**。
        
    - 主要用于**在对象被回收时收到通知**，做后续清理操作。
        
    - `get()` 方法永远返回 `null`。
        
- **应用场景**：
    
    - 资源清理（如直接内存回收）
        
    - 对象回收前做一些额外操作（类似 finalize，但更灵活）
## **引用类型对比表**

|引用类型|是否可用作普通引用|GC 时机|常用场景|
|---|---|---|---|
|强引用|是|GC 不会回收|普通对象|
|软引用|是|内存不足时回收|内存敏感缓存|
|弱引用|是|GC 一发生就回收|ThreadLocal、WeakHashMap|
|虚引用|否|GC 回收时可做通知|清理、回收前处理|

---

✅ **总结思路**：

1. 强引用：普通引用，GC 不回收
    
2. 软引用：内存不足时才回收 → 缓存
    
3. 弱引用：GC 一发生就回收 → 规范映射
    
4. 虚引用：对象回收前通知 → 清理资源