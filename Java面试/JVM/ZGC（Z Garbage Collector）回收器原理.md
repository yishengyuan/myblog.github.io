ZGC 的核心目标只有两个：  
**超低停顿（≤1ms）** + **超大堆（TB级）**
# 🌟 **ZGC 的核心机制 = 并发标记 + 并发移动 + 着色指针（Colored Pointers）+ 读屏障（Load Barrier）**

ZGC 最重要的一句话：

> **ZGC 是一个几乎全程并发的、基于 region 的、支持并发移动对象的垃圾回收器。  
> 它通过“着色指针 + 读屏障”实现对象搬家几乎不 STW。**

# 🧱 **一、Region 分区（动态大小）**

不像 G1 的固定 region 大小，ZGC：

- **Region（ZPage）大小动态：2MB、32MB、64MB**
    
- 根据对象大小自动选择 Region
    
- 巨型对象独占 Region
    

这提高了大堆上的可扩展性。


# 🌲 **二、并发标记（Concurrent Mark）**

ZGC 的标记过程几乎全部并发。

只有一个非常短的 STW：**Roots scanning**。

之后：

- 并发标记整个堆
    
- 和应用线程几乎同时执行
# 🔄 **三、并发重定位（Concurrent Relocation）—— ZGC 最大特点**

这是 ZGC 最厉害的点：

> ZGC 可以 **并发移动对象**，不需要 STW（日常 GC 最痛的点）。

但移动对象后引用会失效，这就是传统 GC 不能并发移动的原因。

ZGC 的解决方案是：

# 🎨 **四、着色指针（Colored Pointer）**

这是 ZGC 最核心的技术！

对象引用本质上是“指针”。ZGC 在指针的**上几位**做“标记位”（不用额外字段）：

|标记位|含义|
|---|---|
|Marked0|标记阶段使用|
|Marked1|标记阶段使用（双 buffer）|
|Remapped|指针是否已被更新|
|Finalizable|finalizable 状态|

这些位用于记录：

- 对象是否已标记
    
- 指针是否已被修复
    
- 对象是否被搬迁
    

👉 **无需额外内存开销，也避免扫描整个堆修复引用。**

---

# 🧱 **五、读屏障（Load Barrier）—— 保证指针正确**

当应用线程**每次读取对象引用**时，ZGC 的读屏障会检查：

- 这个指针是否是旧地址？
    
- 这个对象是否已被搬迁？
    
- 这个指针是否需要修复？
    

必要时：

- 把指针修复到新地址（指向新对象）
    
- 更新着色指针状态
    

👉 **引用修复是按需的，不需全堆扫描。**

---

# 🧩 **六、并发重定位集（Relocation Set）**

ZGC 选择部分 Region 作为 **Relocation Set**，对它们的对象进行搬迁。

为什么只搬迁部分 region？

- 避免全堆移动（移动代价太大）
    
- 提高并发效率
    
- 不需要像 CMS 那样出现碎片
# 📌 **七、过程总结（按步骤）**

ZGC 周期包含 4 个阶段：

### **1）并发标记（Concurrent Mark）**

从 Roots 开始标记存活对象（几乎全程并发）。

### **2）并发准备重定位（Concurrent Relocate Prepare）**

决定哪些 region 需要搬迁（Relocation Set）。

### **3）并发重定位（Concurrent Relocate）**

ZGC 并发搬迁对象，应用线程同时运行。

### **4）并发重映射（Concurrent Remap）**

读屏障保证读时修复旧引用，不需要 STW。

---

# 🎯 **ZGC 实现低延迟的本质原因**

总结为一句可以在面试直接说的话：

> ZGC 通过 **着色指针 + 读屏障 + 并发重定位** 实现了对象移动不需要 stop-the-world，大部分工作都在并发执行，从而让停顿时间控制在 1ms 以下。

---

# 🆚 与其他 GC 对比（简洁加分）

|GC|是否并发移动对象|停顿特性|最大堆|
|---|---|---|---|
|CMS|❌ 不移动，碎片严重|低|小~中|
|G1|✔ 年轻代复制，老年代按区域搬迁|中等停顿|百 GB|
|**ZGC**|✔✔ 全并发移动|**<1ms**|**TB级**|
|Shenandoah|✔✔ 类似于 ZGC|<10ms|几百 GB|
