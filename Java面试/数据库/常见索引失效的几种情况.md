## 1️⃣ 函数或表达式操作列

当查询中对索引列做了函数或运算，索引无法使用：

```
-- 索引在 name 列上
SELECT * FROM user WHERE UPPER(name) = 'TOM';  -- 索引失效
SELECT * FROM user WHERE name + 'a' = 'TomA';   -- 索引失效

```
`

✅ **优化方法**：

- 避免在 `WHERE` 条件中对列使用函数或运算
    
- 如果必须，可以建立 **函数索引**（MySQL 8.0+ 支持表达式索引）
## 3️⃣ 前缀模糊查询（非最左前缀匹配）

```
-- name 列上有索引
SELECT * FROM user WHERE name LIKE '%Tom';  -- 索引失效
SELECT * FROM user WHERE name LIKE 'Tom%';  -- 可以使用索引

```

- **原因**：B-Tree 索引只能高效匹配前缀
    
- **优化方法**：避免前置 `%`，如果必须模糊，可用 **全文索引** 或 **倒排索引**
## 4️⃣ OR 条件或非等值查询

`SELECT * FROM user WHERE id = 1 OR name = 'Tom';  -- 索引可能失效`

- OR 条件如果列都没有复合索引，单个索引无法覆盖整个查询
    
- **优化方法**：
    
    - 用 `UNION` 替代 OR
        
    - 建立复合索引 `(id, name)`
## 5️⃣ IS NULL / IS NOT NULL

`SELECT * FROM user WHERE name IS NOT NULL;  -- 索引可能不被用`

- MySQL 在某些版本对 IS NOT NULL 或 IS NULL 的优化有限
    
- **优化方法**：尽量避免大范围 IS NULL/IS NOT NULL 查询
## 6️⃣ 索引列更新或类型过大

- B-Tree 索引对大文本类型（如 `TEXT`, `BLOB`）通常只索引前 N 个字符
    
- 频繁更新索引列会增加索引维护成本，可能导致查询计划不使用索引
## 7️⃣ 组合索引顺序不正确

- 复合索引 `(A,B)` 查询 `WHERE B=...` 时，索引失效
    
- **优化方法**：确保最常用过滤条件放在复合索引最前面（最左前缀原则）
## 8️⃣ 隐式排序/范围查询导致后续列索引失效

`-- 复合索引 (A,B) SELECT * FROM user WHERE A=1 AND B>5;`

- B 是范围条件，后续列索引无法使用
    
- 复合索引后面列就失效了
    
- **优化方法**：合理设计索引顺序，或者拆分查询
## 9️⃣ 数据量太小，优化器直接全表扫描

- 如果表很小（如几百条记录），即使有索引，优化器也可能选择全表扫描
    
- **这是正常现象，不是索引失效**
    

---

💡 **总结口诀**：

> **函数运算在列上 → 索引失效  
> 前置模糊 LIKE → 索引失效  
> 数据类型不一致 → 索引失效  
> OR/范围/顺序错 → 索引失效**