核心逻辑（支付、资金、余额、订单核心状态）统一放在一个库里，用本地事务保证强一致；  
非核心（库存、营销、推送、积分、退款通知）全部用 **消息队列** 做解耦和最终一致。

这是“**单元化架构 / Core Domain 聚合**”的典型做法，也是阿里、美团、京东、蚂蚁大量使用的模式。
# 📌 为什么大厂要把核心表放一起（而不是分库分区）？

原因非常现实：

## ✔ ① 核心资金数据必须强一致

比如：

- 支付状态（PAID/UNPAID）
    
- 账户余额
    
- 冻结金额
    
- 核心订单状态
    
- 核心流水表（账务流水）
    

这些数据不能用最终一致（因为要命）。

放在同一个库：

- 用单库事务（强一致）
    
- 稳定
    
- 易审计
    
- 性能 predictable
    
- 容错性可控
    

**“一个库 = 一个强一致自治域”**
## ✔ ② 资金系统不允许跨库事务

支付宝 / 微信支付 / 银行清结算 / 京东支付 都是如此。

一旦跨库：

- 要分布式事务（2PC/TCC/Seata）
    
- 成本巨大
    
- 风险上升
    
- 性能下降
    

没有一家大厂敢用跨库强一致去搞支付。

## ✔ ③ 核心库的主从同步延迟可控

核心库数据小、表少  
→ MySQL 的主从延迟非常低（单毫秒级）  
→ 性能稳定

反之，如果你把几百业务表塞进去，延迟高到爆，支付链路都卡死。

---

## ✔ ④ 风控、支付、账务要统一原子性

这些系统要保证一个事务内完成：

例如“支付成功”流程：

`订单状态更新 账务流水写入 余额扣减 冻结金额减少 支付记录写入`

如果这些表分散到不同数据库，账务绝对会混乱。

# 📌 那非核心为什么要用 MQ？

因为：

- 库存更新可以最终一致
    
- 积分奖励可以最终一致
    
- 发券可以最终一致
    
- 推送消息可以最终一致
    
- 订单扩展信息可以最终一致
    
- 会员等级变更可以最终一致
    

核心是：

> 这些业务就算延迟 1 秒、失败重试，也完全没问题。

MQ 的作用是：

- 解耦
    
- 限流
    
- 异步
    
- 不阻塞主链路
    
- 保证最终一致
    
- 错误可重试
    
- 不影响核心库性能
    

---

# 📌 你的方案是什么级别？

我给你一个定位：

> **你提出的方案，就是阿里系电商/支付架构里，最常见、最经典、最通用的设计。**

你可以放心，这就是大厂级标准答案。

---

# 📌 大厂真实案例

## ✔ 阿里（淘宝/支付宝/盒马）

- 支付、账务、核心订单：一个库（甚至一个实例）
    
- 其他业务：MQ（RocketMQ 事务消息 + Kafka）
    
- 异步扩展性极强
    

## ✔ 美团（外卖、支付）

- 支付核心库：单独自治
    
- 订单核心：单独自治
    
- 骑手、配送、优惠券：MQ
    

## ✔ 京东（零售 + 支付）

- 核心订单、支付一起
    
- 物流、ERP、仓储 → 事件驱动
    

## ✔ 字节跳动

- Firehose 事件流 + Outbox
    
- 核心域少表、单库强一致
    

这个架构在整个行业已经是“最佳实践”。

---

# 📌 什么时候不适合这个方案？

只有一种情况：

### ❌ 核心库的 QPS 高到单库扛不住（几十万 QPS 写入）

这种时候需要：

- 分区账务（隔离多类账户）
    
- 库内分表（按 uid 或 orderId hash）
    
- 但仍然保持强一致域不跨库
    

也就是说：就算扩展，也会按照“域”进行，而不是把核心域拆得很散。

---

# 📌 面试答法（超级加分）

你可以这样回答：

> “我们把强一致要求最高、资金敏感的数据都汇聚到同一个库，保证单库事务的原子性和一致性。  
> 非核心部分通过 MQ 做异步解耦，实现最终一致性。  
> 这种做法是大厂支付系统最常用的架构，可以避免分布式事务，同时保持高可用与扩展性。”

面试官会认为这是 **成熟架构师的思维**。