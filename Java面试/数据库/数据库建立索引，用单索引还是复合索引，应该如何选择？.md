## 1️⃣ 单列索引 vs 复合索引

| 类型   | 定义                   | 优点                 | 缺点                       |
| ---- | -------------------- | ------------------ | ------------------------ |
| 单列索引 | 只对某一列建立索引            | 简单，维护成本低，对该列查询快    | 多条件查询可能需要多个索引合并，效率不如复合索引 |
| 复合索引 | 对多列联合建立索引，例如 `(A,B)` | 多条件查询效率高，覆盖索引可减少回表 | 索引顺序重要，维护成本高，过多复合索引占空间   |
|      |                      |                    |                          |
## 2️⃣ 复合索引选择原则

1. **最左前缀原则（Leftmost Prefix）**
    
    - 复合索引 `(A,B,C)` 可加速以下查询：
        
        - `WHERE A=...`
            
        - `WHERE A=... AND B=...`
            
        - `WHERE A=... AND B=... AND C=...`
            
    - 但不能直接加速 `WHERE B=...` 或 `WHERE B=... AND C=...`
        
2. **选择性高的列放前面**
    
    - 选择性：不同值的数量占总行数比例
        
    - 高选择性的列放在复合索引最前面，能更快过滤数据
        
3. **覆盖索引（Covering Index）**
    
    - 如果查询只涉及索引列（`SELECT A,B FROM table WHERE A=? AND B=?`），可直接从索引返回结果，无需回表
        
4. **查询频率和排序**
    
    - 经常被 `WHERE`、`ORDER BY`、`GROUP BY` 使用的列可优先考虑加入复合索引
## 3️⃣ 单列索引适用场景

- 查询条件简单，仅用到某一列
    
- 该列选择性高
    
- 写操作频繁，不希望索引维护成本太高
    

---

## 4️⃣ 复合索引适用场景

- 查询中经常同时使用多列过滤
    
- 需要排序或分组优化
    
- 复合索引列顺序符合最左前缀原则
    
- 查询覆盖率高，减少回表
    

---

## 5️⃣ 实践建议

1. **先分析慢查询**
    
    - 用 `EXPLAIN` 或数据库慢查询日志找出热点查询
        
2. **先优化最频繁查询**
    
    - 针对最常用的 `WHERE`、`JOIN`、`ORDER BY` 优化索引
        
3. **不要过度索引**
    
    - 每增加一个索引，写操作（INSERT/UPDATE/DELETE）成本增加
        
4. **结合单列索引和复合索引**
    
    - 核心表可以用复合索引覆盖多条件查询
        
    - 辅助查询可以用单列索引
