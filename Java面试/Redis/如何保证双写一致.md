**Cache Aside Pattern（旁路缓存模式）**确实会在“读写并发”场景下产生不一致问题。  
很多公司（包含大厂）都知道“先删缓存再写库”，但**理解为什么会不一致、如何解决不一致**才是面试的重点

# ✅ 一、为什么先删除缓存再更新数据库？

（你已经说对了，我帮你补全）

### **方案 1：先更新 DB，再删除缓存（不推荐）**

问题：如果删除缓存失败，缓存就变成脏数据 → 读请求永远读到旧值。

### **方案 2：先删除缓存，再更新 DB（推荐）**

即便删除缓存失败 → 最多只是数据变旧 → 后续读请求会查询数据库 → 补回缓存  
不会永远脏，但会短暂不一致。

➡️ **缓存最终一致**，但不是强一致。
# ❗ 那为什么你说“读和写并发仍然可能不一致”？

因为这两步（删缓存 + 写数据库）不是原子操作，中间存在时间窗口。

我给你画个典型的并发场景（面试官最爱问）：

---

# ❌ 读写并发导致不一致的经典流程（必考）

`线程 A（写）：   1. 删除缓存 线程 B（读）：            2. 发现缓存没了 → 查 DB → 查到旧值 线程 A（写）：                              3. 更新数据库为新值 线程 B（读）：                                           4. 把旧值写回缓存`

最终：

`数据库：新值 缓存：旧值（脏）`

这种情况是 **缓存写回旧值**，是 Cache Aside 的典型问题。

# 🟦 那大厂是如何解决这个问题的？

下面是“真实生产可用 + 面试官爱听”的 5 种方案，从低级到高级。

---

# ✅ 方案 1：给缓存设置短 TTL（大部分公司用）

脏数据不会永久存在，最多几秒。

> 优点：实现简单  
> 缺点：不是强一致，只能尽量降低影响

多数 Web 系统 **无需强一致**（比如商品列表、用户信息查看等），TTL 是足够的。

# ✅ 方案 2：更新数据库后再延迟双删（阿里常用）

写流程：

`1. 删除缓存 2. 更新数据库 3. sleep(几百毫秒) 4. 再删缓存一次`

为什么要 sleep？

因为 sleep 这段时间，让可能的读请求执行完，让它们写回旧缓存，再删掉。

> 优点：小改动，效果好  
> 缺点：不能 100% 干掉并发问题，但概率极低

# ✅ 方案 3：给 key 加分布式锁（Redis SETNX）

读流程：

`查询缓存 → 没命中 → 尝试获取锁 → 命中则查 DB → 写缓存 → 释放锁`

写流程：

`删除缓存 → 更新数据库 → 再次删除缓存`

这个方案可以防止“多个读线程同时查库写缓存”。  
但仍然不能完全解决“读和写同时发生”的问题。

---

# ✅ 方案 4：使用消息队列（MQ）保证顺序

流程：

`写请求 → 删除缓存 → 更新 DB → 发送一个消息 → 消费者统一删除缓存`

这样缓存的删除是最终按顺序执行的。

> 优点：可以做到最终一致  
> 缺点：增加复杂度，要引入 MQ 和重试机制

---

# ✅ 方案 5：完全放弃 Cache Aside，使用 Write-Through / Write-Behind

这是高一致性业务的做法：

### **Write-Through**

写操作先写缓存，由缓存负责再写数据库  
（Redis + RedisModule / 缓存代理层实现）

### **Write-Behind**

写请求只写缓存，由缓存异步批量刷回数据库  
（例如电商购物车）

> 优点：一致性强  
> 缺点：实现复杂，不适合通用场景