一句话：

> **多个客户端在同一时间，对同一个 key 执行读写操作，导致数据出现不一致、覆盖、丢失的情况，这就是 Redis 的并发竞争（Race Condition）。**

Redis 是单线程的，但并发竞争不是指“Redis 内部多线程”，而是：

### **→ 多个客户端并发访问同一 key，顺序不可控

→ 导致写入覆盖、读脏数据、更新丢失等问题**

# ❗三种典型 Redis 并发竞争场景

## **① 读 - 改 - 写 竞争（最常见）**

例子：库存扣减

1. Client A 读库存 `10`
    
2. Client B 读库存 `10`
    
3. A 扣减到 `9`
    
4. B 也扣减到 `9` → **数据丢失**
## **② 多客户端同时写同一个 key**

1. A 写 value = 1
    
2. B 写 value = 2
    
3. 谁后写谁覆盖 → **写覆盖问题**
## **③ 微秒级高并发下的自增、自减竞争**

例如：

`INCR key`

多个请求同时执行，Redis 保证单条指令原子性，可以安全，但如果是：

`value = GET key value = value + 1 SET key value`

就会出现并发冲突 → **必须保证操作整体原子性**

---

# ✅ **如何解决 Redis 并发竞争？（面试重点）**

下面按重要程度排序，面试中推荐这样回答。

---

# 🥇 **1. 使用 Redis 原子操作（最推荐）**

Redis 命令本身是**单线程 + 单指令原子性**，例如：

- `INCR`
    
- `DECR`
    
- `HINCRBY`
    
- `LPUSH / RPOP`
    
- `SETNX`
    
- `GETSET`
    

这些天然不会有并发冲突问题。

**凡是能用原子操作解决的，不要自己拼逻辑。**

# 🥈 **2. 使用 Lua 脚本保证多操作原子化**

比如库存扣减需要：

`GET stock if stock > 0     DECR stock`

这个过程要原子，写成 Lua：

`local stock = redis.call("GET", KEYS[1]) if tonumber(stock) > 0 then     return redis.call("DECR", KEYS[1]) else     return -1 end`

Redis 会以**单条指令方式执行 Lua** → 100% 原子。

👉 **线上系统高并发下扣减库存、抢票、限流等都是 Lua 做的。**

# 🥉 **3. 分布式锁（解决中间业务逻辑较复杂的并发）**

使用：

- `SETNX + EXPIRE`
    
- 或者 **Redisson（推荐，生产级）**
    

保证某段代码同时只有一个客户端在处理：

`lock();     complex logic...  unlock();`

适用于：

- 秒杀
    
- 同一订单避免重复提交
    
- 同一用户同时访问时串行化操作
    

---

# 🕹️ **4. 事务（MULTI / EXEC）**

Redis 事务只是“命令是依次执行”，但 **不保证原子性**  
也不会回滚。

一般用得少 → 推荐 Lua 替代。

# 📦 **5. 用队列/流式模型避免并发（异步串行化）**

通过 **Redis Stream / List**：

- 写入操作变成队列
    
- 后端单 consumer 顺序处理
    

适用于：

- 订单写入
    
- 任务处理
    
- 异步扣减库存（秒杀模式）
    

---

# 🧱 **6. 合理使用过期时间 + 双删（缓存竞争问题）**

并发更新数据库 + Redis 时，避免：

- 缓存不一致
    
- 脏数据
    

常用策略：

- Cache Aside Pattern
    
- 先删除缓存 → 更新数据库 → 延迟双删
    

---

# 🔥 面试官最想听到的一句话总结（可以背）：

> Redis 是单线程，所以指令级原子性没问题，但多客户端并发访问同一 key 时会发生竞态，导致更新丢失或覆盖。  
> 解决方式是：**优先用原子命令，其次用 Lua 脚本保证原子，多逻辑用分布式锁，最后必要时用异步队列串行化处理。**

	