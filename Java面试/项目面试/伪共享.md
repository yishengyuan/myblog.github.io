# ✅ 一句话理解伪共享

> **伪共享：多个线程修改不同变量，但这些变量刚好落在同一个 CPU Cache Line 里，导致每次修改都会互相使缓存失效，引发严重的性能下降。**

它不是数据共享，但“看起来像共享”，所以叫**伪共享**。

---

# 🔬 CPU 是怎么导致伪共享的？

先理解两个关键点：

### ✔ 1. CPU 缓存以 Cache Line 为单位加载

常见 **Cache Line 大小是 64 字节**。

只要访问变量 A，会把 A 所在的 **整 64-byte 区块** 都加载到缓存。

### ✔ 2. 多核 CPU 对同一 Cache Line 有一致性协议（MESI）

如果某个线程修改了一个 Cache Line，其他核上的 Cache Line 会被标记为 **失效（Invalid）**，需要重新拉取。

# 🧨 伪共享是怎么发生的？

比如有两个变量：

`long a;  // 线程1 修改 long b;  // 线程2 修改`

如果 a 和 b 在内存里排列在 64 字节以内，就会共享同一个 Cache Line：

`| a | b |  ... (同一个 Cache Line) ... |`

### ❗ 问题来了：

线程1 修改 a → 整个 Cache Line 被置为“已修改(MODIFIED)”

线程2 想修改 b → 发现自己的 Cache Line 被标记“Invalid”，必须重新拉取

→ 重复不断  
→ 两个线程互相导致对方缓存失效  
→ CPU 一直同步 Cache Line  
→ 性能 **暴跌数十倍**

虽然它们根本 **没有共享数据**，却被当成共享了 —— **伪共享**。

# 🚀 面试最喜欢的例子（Java）

下面的代码在多核 CPU 下性能非常差：

```
public class FalseSharing implements Runnable {
    public static long[] arr = new long[2];

    private int index;

    public FalseSharing(int index) {
        this.index = index;
    }

    @Override
    public void run() {
        for (long i = 0; i < 10_000_000L; i++) {
            arr[index] = i; // 不同线程写不同位置，但还是冲突
        }
    }
}

```

**原因：arr[0] 和 arr[1] 可能在同一个 Cache Line → 伪共享。**

# 🔧 如何解决伪共享？（面试重点）

### 方法1：填充（Padding）

手动让变量跨越多个 Cache Line，例如加 dummy 字段：

`class Padding {     public volatile long value = 0L;     public long p1, p2, p3, p4, p5, p6; // 占位填充 }`

让每个对象占用大于 64 字节空间，避免挤在一起。

---

### 方法2：@Contended（JDK 8+）

Java 官方提供：

```
@sun.misc.Contended
public volatile long value;
`
```

运行 JVM 要加：

`-XX:-RestrictContended`

这样 JVM 自动帮你隔离 Cache Line。
### 方法3：将热点变量分散在不同对象里

让对象分配在不同内存区域，不容易在同一个 Cache Line。

---

# 📌 总结（适合放进面试回答里）

> **伪共享（False Sharing）是多线程性能杀手：多个线程修改不同变量，但这些变量落在同一个 Cache Line 导致缓存一致性频繁触发，造成性能急剧下降。  
> 解决方式包括 Padding、@Contended、变量分散等方法。**


