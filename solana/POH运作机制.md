# 🧠 先用一句话理解 PoH 是什么？

> **PoH = 一个无法造假的“加密时间轴”**  
> 节点不断对上一个哈希做哈希，形成连续、不可逆、可验证的时间序列。

你可以把它理解为：

- **一个链上运行的加密时钟**
    
- 谁都能证明“第 5000 个哈希一定发生在第 4999 个哈希之后”
    
- 节点不需要互相同步时间，就能知道交易的发生顺序
# 🏃‍♂️ 为什么要 PoH？

传统链（BTC/ETH）排序交易靠的是：

- “大家互相通信 → 谁先广播 → 共识再排序”
    

非常慢。

Solana 说：  
“我不问时间，我自己造一个 **哈希生成的时间流**。”

# 🔥 PoH 的核心公式（非常关键）

PoH 使用一个连续递归哈希：

`h0 = seed h1 = hash(h0) h2 = hash(h1) h3 = hash(h2) ... hn = hash(hn-1)`

只要 hash 函数是不可逆（SHA-256），就能保证：

- h100 只能在算完 h99 后才能出现
    
- 无法并行
    
- 无法跳过
    

这就是 **时间的不可逆性**。

# 🕰️ PoH 的运行机制（通俗解释）

下面用实际步骤拆解它：

---

## **① 生成连续递归哈希作为“滴答滴答”的时间流**

一个 Solana Leader 节点会持续不停执行：

`hash = sha256(hash)`

每一次 hash 就像“时钟跳了一下”。

比如：

`第 1 下：A 第 2 下：B 第 3 下：C ...`

所有节点都能验证这条哈希链是逐个算出来的，而不是一次性伪造的。

## **② 交易插入到这个时间流中**

当节点收到交易时，它不会马上打包，而是把交易的数据插入哈希链：

例如：

`h500 = hash(h499) h501 = hash(h500 + TX1) h502 = hash(h501) h503 = hash(h502 + TX2)`

这样，其他节点就能明确知道：

- TX1 发生在 h501 这个“时间点”
    
- TX2 发生在 h503 后
    

交易的顺序完全由这个哈希链的顺序决定。

**这就做到了：不用节点互相同步，也能知道顺序。**

## **③ 所有节点都可以快速验证 PoH**

验证规则非常简单：

> “只要我从 h0 开始按顺序哈希，就应该能算出 h1、h2、h3…”

因此验证速度非常快，几乎等于看一个连续增长的时间轴。

验证成本低 → TPS 超高。

# 🔍 再用一个更形象的比喻

## **PoH = 录像机 + 时间戳**

想象你有一台摄像机：

- 它不停录影（哈希不停进行）
    
- 每 1 秒录下一帧（每一步递归哈希）
    
- 当有事件（交易）发生，就把事件写进那一帧画面里
    

当别人看到录像时：

- 不用问任何人“这是谁先谁后”
    
- 因为录像已经记录了时间顺序
# 用动态例子演示：真的很容易理解

### **Leader 节点开始记录时间（不断哈希）**

`H0 → H1 → H2 → H3 → H4 → H5 → ...`

### **交易来了**

`H0 → H1 → H2(Tx A) → H3 → H4(Tx B) → H5 → ...`

每个 hash 就像“第 X 毫秒”。

其他节点收到这串 hash 时：

**一眼就能看到谁先谁后：**

- Tx A 发生在 H2
    
- Tx B 发生在 H4
    
- A 先于 B
    

不需要节点互相沟通，不需要复杂通信。

⚡ **这就是 Solana 排序快到变态的原因。**

# 🧩 PoH 和普通区块链排序的区别

| 技术              | 排序方式         | 缺点     |
| --------------- | ------------ | ------ |
| **比特币**         | 谁先广播谁排前面     | 网络延迟严重 |
| **以太坊**         | 按收到交易的顺序排序   | 受带宽影响  |
| **Solana（PoH）** | 排序写入时间轴，无需沟通 | 超高性能   |


因此：

> **Solana 的交易排序不是靠节点之间的通信，而是靠“加密时间钟”。**

---

# 🏁 最终一句最通俗的总结

**PoH = 一条节点不停生成的哈希链，把每笔交易“镶嵌”进这条链上，这样全网都能证明交易先后顺序，而无需互相交流。**
